<!DOCTYPE html PUBLIC "-//W3C//DTD html 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<title>pg_rman</title>
<link rel="home" title="pg_rman" href="index.html">
<link rel="stylesheet" TYPE="text/css"href="style.css">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
</head>

<body>
<h1 id="pg_rman">pg_rman 1.3</h1>
    <a href="index-ja.html">documentation in Japanese</a>
<hr />

<body>
<div class="index">
<ol>
<li><a href="#name">Name</a></li>
<li><a href="#synopsis">Synopsis</a></li>
<li><a href="#description">Description</a></li>
<li><a href="#examples">Examples</a></li>
<li><a href="#options">Options</a></li>
<li><a href="#waytopassoptions">Way to pass options</a></li>
<li><a href="#restrictions">Restrictions</a></li>
<li><a href="#details">Details</a></li>
<li><a href="#externalscript">External Scripts</a></li>
<li><a href="#download">Download</a></li>
<li><a href="#install">Installation</a></li>
<li><a href="#requirement">Requirements</a></li>
<li><a href="#seealso">See Also</a></li>
</ol>
</div>

<h1 id="Name">Name</h1>
<p>pg_rman -- manages backup and recovery of PostgreSQL.</p>

<h1 id="Synopsis">Synopsis</h1>

<pre>
<code>pg_rman [ OPTIONS ] { init |
                      backup |
                      restore |
                      show [ DATE | detail ] |
                      validate [ DATE ] |
                      delete DATE |
                      purge }
</code></pre>

<p>pg_rman has the features below:</p>

<ul>
<li>Takes a backup of entire database including tablespaces with just one command.</li>
<li>Can recovery from backup with just one command.</li>
<li>Supports incremental backup and compression of backup files so that it takes less disk spaces.</li>
<li>Manages backup versions and shows a catalog of the backups.</li>
<li>Supports storage snapshot.</li>
</ul>


<p><code>DATE</code> is the start time of the target backup in ISO-format (YYYY-MM-DD HH:MI:SS). Prefix match is used to compare <code>DATE</code> and backup files.</p>

<pre><code>$ pg_rman show 2009-12 # show backups in a month of December 2009
$ pg_rman validate     # validate all unvalidated backups
</code></pre>

<p>pg_rman supports the following commands. See also <a href="#options">Options</a> for details of <code>OPTIONS</code>.</p>

<ul>
<li><code>init</code>

<ul>
<li>Initialize a backup catalog.</li>
</ul>
</li>
<li><code>backup</code>

<ul>
<li>Take an online backup.</li>
</ul>
</li>
<li><code>restore</code>

<ul>
<li>Do restore.</li>
</ul>
</li>
<li><code>show</code>

<ul>
<li>Show backup history. The detail option shows with additional information of each backups.</li>
</ul>
</li>
<li><code>validate</code>

<ul>
<li>Validate backup files. Backups without validation cannot be used for restore and incremental backup.</li>
</ul>
</li>
<li><code>delete</code>

<ul>
<li>Delete backup files.</li>
</ul>
</li>
<li><code>purge</code>

<ul>
<li>Remove deleted backups from backup catalog.</li>
</ul>
</li>
</ul>


<h1 id="Description">Description</h1>

<p>pg_rman is a utility program to backup and restore PostgreSQL database. It takes a physical online backup of whole database cluster, archive WALs, and server logs.</p>

<p>pg_rman supports getting backup from standby-site with PostgreSQL 9.0 later, also supports storage snapshot backup.</p>

<h2>Initialize a backup catalog</h2>

<p>First, you need to create "a backup catalog" to store backup files and their metadata.</p>

<pre><code>$ pg_rman init -B &lt;a backup catalog path&gt;
</code></pre>

<p>It is recommended to setup <code>log_directory</code>, <code>archive_mode</code> and <code>archive_command</code> in postgresql.conf before initialize the backup catalog. If the variables are initialized, pg_rman can adjust the configuration file to the setting. In this case, you have to specify the database cluster path for PostgreSQL. Please specify it in <code>PGDATA</code> environmental variable or <code>-D</code>/<code>--pgdata</code> option.</p>

<h2>Backup</h2>

<p>The mode of backup can be one of the following types.</p>

<ul>
<li><strong>Full backup</strong>

<ul>
<li>Backup a whole database cluster.</li>
</ul>
</li>
<li><strong>Incremental backup</strong>

<ul>
<li>Backup only files or pages modified after the last verified backup with the same timeline.</li>
</ul>
</li>
<li><strong>Archive WAL backup</strong>

<ul>
<li>Backup only archive WAL files.</li>
</ul>
</li>
</ul>
<p>Pg_rman also can backup PostgreSQL server log files.</p>

<h2>Validate backup data</h2>

<p>It is necessary to validate the data backuped by pg_rman. Pg_rman uses file size check and CRC for validation.</p>

<p>It is recommended to verify backup files as soon as possible after backup. Unverified backup cannot be used in restore nor in incremental backup.</p>

<h2>View backup information</h2>

<p>The <code>show</code> command outputs backup lists.</p>

<pre><code>$ pg_rman show
 ==========================================================
 StartTime           Mode  Duration    Size   TLI  Status
 ==========================================================
 2015-03-27 11:43:31  INCR        0m    54kB     1  OK
 2015-03-27 11:43:19  INCR        0m    69kB     1  OK
 2015-03-27 11:43:04  INCR        0m   151kB     1  OK
 2015-03-27 11:42:56  INCR        0m    96kB     1  OK
 2015-03-27 11:34:55  FULL        0m  5312kB     1  OK
</code></pre>

<p><code>show detail</code> command shows more detail information.</p>

<pre><code>$ pg_rman show detail
 ============================================================================================================
 StartTime           Mode  Duration    Data  ArcLog  SrvLog   Total  Compressed  CurTLI  ParentTLI  Status
 ============================================================================================================
 2015-03-27 11:43:31  INCR        0m    16kB    33MB    ----    54kB        true       1          0  OK
 2015-03-27 11:43:19  INCR        0m   148kB    33MB    ----    69kB        true       1          0  OK
 2015-03-27 11:43:04  INCR        0m   173kB    83MB    ----   151kB        true       1          0  OK
 2015-03-27 11:42:56  INCR        0m   173kB    50MB    ----    96kB        true       1          0  OK
 2015-03-27 11:34:55  FULL        0m    28MB    83MB    ----  5312kB        true       1          0  OK
</code></pre>

<p>The fields are:</p>
<ul>
<li>StartTime : start time of backup</li>
<li>Mode : mode of backup.
<ul>
<li>FULL : full backup</li>
<li>INCR : incremental backup</li>
<li>ARCH : archive WAL backup</li>
</ul>
</li>
<li>Duration : total time of backup</li>
<li>Data : size of read data files</li>
<li>ArcLog : size of read archive WAL files</li>
<li>SrvLog : size of read server log files</li>
<li>Size/Total : size of backup ( = written size)</li>
<li>Compressed : whether backup is compressed or not</li>
<li>TLI/CurTLI : timeline ID of PostgreSQL</li>
<li>ParentTLI : former timeline ID of PostgreSQL</li>
<li>Status: status of backup. Possible values are: 
<ul>
<li>OK : backup is done successfully and validated.</li>
<li>DONE : backup is done successfully.</li>
<li>RUNNING : backup is still running.</li>
<li>DELETING : backup is being deleted.</li>
<li>DELETED : backup has been deleted.</li>
<li>ERROR : some errors occur during backup.</li>
<li>CORRUPT : backup is unavailable because it does not pass validation.</li>
</ul>
</li>
</ul>

<p>And more, when you specify the date in &ldquo;Start&rdquo; field, you can see the detail information of the backup.</p>

<pre><code>$ pg_rman show '2011-11-27 19:15:45'
# configuration
BACKUP_MODE=FULL
WITH_SERVERLOG=false
COMPRESS_DATA=false
# result
TIMELINEID=1
START_LSN=0/08000020
STOP_LSN=0/080000a0
START_TIME='2011-11-27 19:15:45'
END_TIME='2011-11-27 19:19:02'
RECOVERY_XID=1759
RECOVERY_TIME='2011-11-27 19:15:53'
TOTAL_DATA_BYTES=1242420184
READ_DATA_BYTES=25420184
READ_ARCLOG_BYTES=32218912
WRITE_BYTES=242919520
BLOCK_SIZE=8192
XLOG_BLOCK_SIZE=8192
STATUS=OK
</code></pre>

<h2>Restore</h2>

<p>Pg_rman restore the backuped data into target database cluster path.</p>

<p>PostgreSQL server should be stopped before restore. In addition, do not erase a original database cluster, because pg_rman has to check the timeline ID or data checksum status from it. Restore command will save unarchived transaction log and delete all database files. You can retry recovery until a new backup is taken. After restoring files, pg_rman create recovery.conf in <code>$PGDATA</code>. The conf file contains parameters to recovery, and you can also modify the file if needed.</p>

<p>It is recommended to take a full backup as soon as possible after recovery is succeeded.</p>

<p>If <code>--recovery-target-timeline</code> is not specified, the last checkpoint&rsquo;s TimeLineID in control file (<code>$PGDATA/global/pg_control</code>) will be a restore target. If pg_control is not present, TimeLineID in the full backup used by the restore will be a restore target.</p>

<h2>Delete backups</h2>

<p>The delete command deletes all backup files before the specified date not required by other incremental backups. Incremental backups depend on earlier validated full backup.</p>
<p> The following example deletes unneeded backup files to recovery at 12:00 11, September 2009.</p>

<pre><code>$ pg_rman show
==========================================================
 StartTime           Mode  Duration    Size   TLI  Status
==========================================================
2015-07-30 13:31:08  FULL        0m    14MB    15  OK
2015-07-30 13:30:37  ARCH        0m    53kB    15  OK
2015-07-30 13:30:32  ARCH        0m    26kB    15  OK
2015-07-30 13:30:11  FULL        0m    14MB    15  OK
2015-07-30 13:28:10  INCR        0m   120kB    14  OK
2015-07-30 13:27:45  INCR        0m    54kB    14  OK
2015-07-30 13:27:32  INCR        0m    54kB    14  OK
2015-07-30 13:27:25  INCR        0m    54kB    14  OK
2015-07-30 13:24:02  FULL        0m    14MB    14  OK

$ pg_rman delete 2015-07-30 13:30:30
WARNING: cannot delete backup with start time "2015-07-30 13:30:11"
DETAIL: This is the latest full backup necessary for successful recovery.
INFO: delete the backup with start time: "2015-07-30 13:28:10"
INFO: delete the backup with start time: "2015-07-30 13:27:45"
INFO: delete the backup with start time: "2015-07-30 13:27:32"
INFO: delete the backup with start time: "2015-07-30 13:27:25"
INFO: delete the backup with start time: "2015-07-30 13:24:02"

$ pg_rman show
==========================================================
 StartTime           Mode  Duration    Size   TLI  Status
==========================================================
2015-07-30 13:31:08  FULL        0m    14MB    15  OK
2015-07-30 13:30:37  ARCH        0m    53kB    15  OK
2015-07-30 13:30:32  ARCH        0m    26kB    15  OK
2015-07-30 13:30:11  FULL        0m    14MB    15  OK
</code></pre>


<h2>Remove deleted backups</h2>
<p>Though <code>delete</code> command removes actual data from file system, there remains some catalog information of deleted backups. In order to remove this, execute <code>purge</code> command.</p>

<pre><code>$ pg_rman show -a
==========================================================
 StartTime           Mode  Duration    Size   TLI  Status
==========================================================
2015-07-30 13:31:08  FULL        0m    14MB    15  OK
2015-07-30 13:30:37  ARCH        0m    53kB    15  OK
2015-07-30 13:30:32  ARCH        0m    26kB    15  OK
2015-07-30 13:30:11  FULL        0m    14MB    15  OK
2015-07-30 13:28:10  INCR        0m   120kB    14  DELETED
2015-07-30 13:27:45  INCR        0m    54kB    14  DELETED
2015-07-30 13:27:32  INCR        0m    54kB    14  DELETED
2015-07-30 13:27:25  INCR        0m    54kB    14  DELETED
2015-07-30 13:24:02  FULL        0m    14MB    14  DELETED

$ pg_rman purge
INFO: DELETED backup "2015-07-30 13:28:10" is purged
INFO: DELETED backup "2015-07-30 13:27:45" is purged
INFO: DELETED backup "2015-07-30 13:27:32" is purged
INFO: DELETED backup "2015-07-30 13:27:25" is purged
INFO: DELETED backup "2015-07-30 13:24:02" is purged

$ pg_rman show -a
==========================================================
 StartTime           Mode  Duration    Size   TLI  Status
==========================================================
2015-07-30 13:31:08  FULL        0m    14MB    15  OK
2015-07-30 13:30:37  ARCH        0m    53kB    15  OK
2015-07-30 13:30:32  ARCH        0m    26kB    15  OK
2015-07-30 13:30:11  FULL        0m    14MB    15  OK
</code></pre>

<h2 id="Standby-site.Backup">Standby-site Backup</h2>

<p>If you use replication feature on PostgreSQL 9.0 later, you can get backup from standby-site.</p>

<p>You should specify different options from usual use for getting backup from standby-site. In detail, you should specify the database cluster on standby-site by <code>-D</code>/<code>--pgdata</code> option. And you should specify information on master-site by connection options (<code>-d</code>/<code>--dbname</code>, <code>-h</code>/<code>--host</code>, <code>-p</code>/<code>--port</code>). In addition, you should specify information to connect standby-site by standby connection options (<code>--standby-host</code>, <code>--standby-port</code>).</p>

<pre><code>$ pg_rman init -B &lt;a backup catalog path&gt; -D &lt;(the database cluster path(on standby-site)&gt;
</code></pre>


<p>Here shows an example with the below environment.</p>

<ul>
<li>the hostname of master-site: master</li>
<li>the hostname of standby-site: localhost</li>
<li>the port number of standby-site: 5432</li>
<li>the database cluster path of standby-site: /home/postgres/pgdata_sby</li>
</ul>

<p>Then, the backup from standby site can be done with the below command:</p>

<pre><code>$ pg_rman backup --pgdata=/home/postgres/pgdata_sby --backup-mode=full --host=master --standby-host=localhost --standby-port=5432
</code></pre>


<h1 id="Examples">Examples</h1>
<p>
In this example, let's consider about PostgreSQL server with the following configurations.
</p>

<pre><code>postgres=# SHOW log_directory ;
 log_directory
---------------
 pg_log
(1 row)

postgres=# SHOW archive_command ;
              archive_command
--------------------------------------------
 cp %p /home/postgres/arc_log/%f
(1 row)
</code></pre>

<p>
And the <code>PGDATA</code> and <code>BACKUP_PATH</code> are set as environment variables.
</p>

<pre><code>$ echo $PGDATA
/home/postgres/pgdata
$ echo $BACKUP_PATH
/home/postgres/backup
</code></pre>

<p>Initialize a backup catalog.</p>

<pre><code>$ pg_rman init
INFO: ARCLOG_PATH is set to '/home/postgres/arclog'
INFO: SRVLOG_PATH is set to '/home/postgres/pgdata/pg_log'
</code></pre>

<p>
By this, the configuration file for pg_rman, named <code>pg_rman.init</code>, is created.
All the commands of pg_rman load configurations from this file as default.
</p>

<p>For this example, we use the following configurtaions.</p>

<pre><code>$ cat $BACKUP_PATH/pg_rman.ini
ARCLOG_PATH = /home/postgres/arclog
SRVLOG_PATH = /home/postgres/pgdata/pg_log

BACKUP_MODE = F
COMPRESS_DATA = YES
KEEP_ARCLOG_FILES = 10
KEEP_DATA_GENERATIONS = 3
KEEP_SRVLOG_FILES = 10
</code></pre>

<p>Then, do a backup.
It should be start from a full backup.
Here, we will also take server log files.
</p>

<pre><code>$ pg_rman backup --backup-mode=full --with-serverlog --progress
INFO: copying database files
Processed 1760 of 1760 files, skipped 0
NOTICE:  pg_stop_backup complete, all required WAL segments have been archived
INFO: copying archived WAL files
Processed 21 of 21 files, skipped 0
INFO: copying server log files
Processed 1 of 1 files, skipped 0
INFO: backup complete
HINT: Please execute 'pg_rman validate' to verify the files are correctly copied.
INFO: start deleting old archived WAL files from ARCLOG_PATH (keep files = 10)
INFO: delete "0000000E0000000100000092"
INFO: delete "0000000E0000000100000092.00000028.backup"
INFO: delete "0000000E0000000100000093"
INFO: start deleting old server files from SRVLOG_PATH (keep files = 10)
INFO: start deleting old backup (keep generations = 3)
INFO: does not include the backup just taken
</code></pre>

<p>Check the result by <code>show</code> command.</p>

<pre><code>$ pg_rman show
==========================================================
 StartTime           Mode  Duration    Size   TLI  Status
==========================================================
2015-07-30 13:36:38  FULL        0m    15MB    15  DONE
</code></pre>

<p>
The status of the backup we have just taken is DONE.
This is because we does not do validate yet.
So, do <code>validate</code> command next.
</p>

<pre><code>$ pg_rman validate
INFO: validate: "2015-07-30 13:36:38" backup, archive log files and server log files by CRC
INFO: backup "2015-07-30 13:36:38" is valid

$ pg_rman show
==========================================================
 StartTime           Mode  Duration    Size   TLI  Status
==========================================================
2015-07-30 13:36:38  FULL        0m    15MB    15  OK
</code></pre>

<p>
Now the status has been changed to OK.
</p>

<p>Let's try to restore the backup data. Before try to do it, PostgreSQL server should be stopped.</p>

<pre><code>$ pg_ctl stop -m immediate
$ pg_rman restore
</code></pre>

<p>
The pg_rman has created recovery.conf in $PGDATA by restore command.
If necessary, modify it as you wanted.
In this example, we use this without modifications and will try to do PITR to latest database status.
</p>

<pre><code>$ cat $PGDATA/recovery.conf
# recovery.conf generated by pg_rman 1.2.11
restore_command = 'cp /home/postgres/arclog/%f %p'
recovery_target_timeline = '1'
$ pg_ctl start
</code></pre>

<h1 id="options">Options</h1>

<p>pg_rman accepts the following command line parameters. Some of them can be also specified as environment variables.</p>

<h2>Common options</h2>

<p>As a general rule, paths for data location need to be specified as absolute paths; relative paths are not allowed.</p>

<ul>
<li><strong><code>-D PATH</code> / <code>--pgdata=PATH</code></strong>

<ul>
<li>The absolute path of database cluster. Required on backup and restore.</li>
</ul>
</li>
<li><strong><code>-A PATH</code> / <code>--arclog-path=PATH</code></strong>

<ul>
<li>The absolute path of archive WAL directory. Required on backup and restore.</li>
</ul>
</li>
<li><strong><code>-S PATH</code> / <code>--srvlog-path=PATH</code></strong>

<ul>
<li>The absolute path of server log directory. Required on backup with server logs and restore.</li>
</ul>
</li>
<li><strong><code>-B PATH</code> / <code>--backup-path=PATH</code></strong>

<ul>
<li>The absolute path of backup catalog. Always required.</li>
</ul>
</li>
<li><strong><code>-c</code> / <code>--check</code></strong>

<ul>
<li>If specifed, pg_rman doesn&rsquo;t perform actual jobs but only checks parameters and required resources. The option is typically used with <code>--verbose</code> option to verify the operation.</li>
</ul>
</li>
<li><strong><code>-v</code> / <code>--verbose</code></strong>

<ul>
<li>If specified, pg_rman works in verbose mode.</li>
</ul>
</li>
<li><strong><code>-P</code> / <code>--progress</code></strong>

<ul>
<li>If specified, pg_rman keep showing number of files it processed during backup or restore.</li>
</li>
</ul>


<h2>Backup options</h2>

<ul>
<li><strong><code>-b { full | incremental | archive }</code> / <code>--backup-mode={ full | incremental | archive }</code></strong>

<ul>
<li>Specify backup target files. Available options are: <code>full</code> backup, <code>incremental</code> backup, and <code>archive</code> backup. Abbreviated forms (prefix match) are also available. For example, <code>-b f</code> means <code>full</code> backup.

<ul>
<li>full : Whole database backup and archive backup</li>
<li>incremental : Incremental backup and archive backup</li>
<li>archive : Only archive backup</li>
</ul>
</li>
</ul>
</li>
<li><strong><code>-s</code> / <code>--with-serverlog</code></strong>

<ul>
<li>Backup server log files if specified.</li>
</ul>
</li>
<li><strong><code>-Z</code> / <code>--compress-data</code></strong>

<ul>
<li>Compress backup files with zlib if specified.</li>
</ul>
</li>
<li><strong><code>-C</code> / <code>--smooth-checkpoint</code></strong>

<ul>
<li>Checkpoint is performed on every backups. If the option is specified, do smooth checkpoint then. See also the second argument for <a href="http://www.postgresql.org/docs/current/static/functions-admin.html"><code>pg_start_backup()</code></a>.</li>
</ul>
</li>
<li><strong><code>--keep-data-generations</code> / <code>--keep-data-days</code></strong>

<ul>
<li>Specify how long backuped data files will be kept. <code>--keep-data-generations</code> means number of backup generations. <code>--keep-data-days</code> means days to be kept. If these two options are specified together, old files exceeded both settings are deleted.</li>
</ul>
</li>
<li><strong><code>--keep-arclog-files</code> / <code>--keep-arclog-days</code></strong>

<ul>
<li>Specify how long archive WAL files already archived will be kept. <code>--keep-arclog-files</code> means number of files. <code>--keep-arclog-days</code> means days to be kept. When you do backup, only files which have been already backuped and exceeded specified condition are deleted from archive log directory ($ARCLOG_PATH). If these two options are given together, pg_rman deletes files which are old enough against both conditions.</li>
</ul>
</li>
<li><strong><code>--keep-srvlog-files</code> / <code>--keep-srvlog-days</code></strong>

<ul>
<li>Specify how long backuped serverlog files will be kept. <code>--keep-srvlog-files</code> means number of files. <code>--keep-srvlog-days</code> means days to be kept. When you do backup, only files exceeded specified condition are deleted from server log directory (log_directory). This option works when you specify <code>--with-serverlog</code> and <code>--srvlog-path</code> options in backup command. If these two options are given toghether, pg_rman deletes files which are old enough against both conditions.</li>
</ul>
</li>
</ul>


<h2>Restore options</h2>

<p>The parameters which are started with &ndash;recovery are same as parameters in recovery.conf. See also &ldquo;<a href="http://www.postgresql.org/docs/current/static/recovery-config.html">Recovery Configuration</a>&rdquo; for details.</p>

<ul>
<li><strong><code>--recovery-target-timeline TIMELINE</code></strong>

<ul>
<li>Specifies recovering into a particular timeline. If not specified, the current timeline from (<code>$PGDATA/global/pg_control</code>) is used.</li>
</ul>
</li>
<li><strong><code>--recovery-target-time TIMESTAMP</code></strong>

<ul>
<li>This parameter specifies the time stamp up to which recovery will proceed. If not specified, continue recovery to the latest time.</li>
</ul>
</li>
<li><strong><code>--recovery-target-xid XID</code></strong>

<ul>
<li>This parameter specifies the transaction ID up to which recovery will proceed. If not specified, continue recovery to the latest xid.</li>
</ul>
</li>
<li><strong><code>--recovery-target-inclusive</code></strong>

<ul>
<li>Specifies whether we stop just after the specified recovery target (true), or just before the recovery target (false). Default is true. 
</ul>
</li>
</li>
</ul>

<p>The following parameter determines the behavior of restore.</p>
<ul>
<li><strong><code>--hard-copy</code></strong>

<ul>
<li>The archive WAL are copied to archive WAL storage area. If not specified, pg_rman makes symbolic link to archive WAL where are in the backup catalog directory.</li>
</ul>
</li>
</ul>


<h2>Catalog options</h2>

<ul>
<li><strong><code>-a</code> / <code>--show-all</code></strong>

<ul>
<li>Show also deleted backups.</li>
</ul>
</li>
</ul>


<h2>Connection options</h2>

<p>Parameters to connect PostgreSQL server.</p>

<ul>
<li><strong><code>-d DBNAME</code> / <code>--dbname=DBNAME</code></strong>

<ul>
<li>The database name to execute pg_start_backup() and pg_stop_backup().</li>
</ul>
</li>
<li><strong><code>-h HOSTNAME</code> / <code>--host=HOSTNAME</code></strong>

<ul>
<li>Specifies the host name of the machine on which the server is running. If the value begins with a slash, it is used as the directory for the Unix domain socket.</li>
</ul>
</li>
<li><strong><code>-p PORT</code> / <code>--port=PORT</code></strong>

<ul>
<li>Specifies the TCP port or local Unix domain socket file extension on which the server is listening for connections.</li>
</ul>
</li>
<li><strong><code>-U USERNAME</code> / <code>--username=USERNAME</code></strong>

<ul>
<li>User name to connect as.</li>
</ul>
</li>
<li><strong><code>-w</code> / <code>--no-password</code></strong>

<ul>
<li>Never issue a password prompt. If the server requires password authentication and a password is not available by other means such as a .pgpass file, the connection attempt will fail. This option can be useful in batch jobs and scripts where no user is present to enter a password.</li>
</ul>
</li>
<li><strong><code>-W</code> / <code>--password</code></strong>

<ul>
<li> Force pg_rman to prompt for a password before connecting to a database. This option is never essential, since pg_rman will automatically prompt for a password if the server demands password authentication. However, pg_rman will waste a connection attempt finding out that the server wants a password. In some cases it is worth typing -W to avoid the extra connection attempt.</li>
</ul>
</li>
</ul>


<h2>Standby connection options</h2>

<p>Parameters to connect standby server. They are used only when you get backup from the standby site.</p>

<ul>
<li><strong><code>--standby-host</code></strong>

<ul>
<li>Specifies the host name of the machine on which the standby server is running. If the value begins with a slash, it is used as the directory for the Unix domain socket.</li>
</ul>
</li>
<li><strong><code>--standby-port</code></strong>

<ul>
<li>Specifies the TCP port or local Unix domain socket file extension on which the server is listening for connections.</li>
</ul>
</li>
</ul>


<h2>Generic options</h2>

<ul>
<li><strong><code>--help</code></strong>

<ul>
<li>Print help, then exit.</li>
</ul>
</li>
<li><strong><code>-V</code> / <code>--version</code></strong>

<ul>
<li>Print version information, then exit.</li>
</ul>
</li>
<li><strong><code>-!</code> / <code>--debug</code></strong>

<ul>
<li>Show debug information.</li>
</ul>
</li>
</ul>


<h1 id="waytopassoptions">Way to pass options</h1>

<p>Some of parameters can be specified in command line arguments, environment variables or configuration file as follows:</p>

<table>
<thead>
<tr>
<th>Short</th>
<th>Long</th>
<th>Environment variable</th>
<th>Conf file</th>
<th>Description</th>
<th>Remarks</th>
</tr>
</thead>
<tbody>
<tr>
<td>-h</td>
<td>&ndash;host</td>
<td>PGHOST</td>
<td></td>
<td>database server host or socket directory</td>
<td></td>
</tr>
<tr>
<td>-p</td>
<td>&ndash;port</td>
<td>PGPORT</td>
<td></td>
<td>database server port</td>
<td></td>
</tr>
<tr>
<td>-d</td>
<td>&ndash;dbname</td>
<td>PGDATABASE</td>
<td></td>
<td>database to connect</td>
<td></td>
</tr>
<tr>
<td>-U</td>
<td>&ndash;username</td>
<td>PGUSER</td>
<td></td>
<td>user name to connect as</td>
<td></td>
</tr>
<tr>
<td></td>
<td></td>
<td>PGPASSWORD</td>
<td></td>
<td>password used to connect</td>
<td></td>
</tr>
<tr>
<td>-w</td>
<td>&ndash;no-password</td>
<td> </td>
<td></td>
<td>never prompt for password</td>
<td></td>
</tr>
<tr>
<td>-W</td>
<td>&ndash;password</td>
<td></td>
<td></td>
<td>force password prompt</td>
<td></td>
</tr>
<tr>
<td>-D</td>
<td>&ndash;pgdata</td>
<td>PGDATA</td>
<td>Yes</td>
<td>location of the database storage area</td>
<td></td>
</tr>
<tr>
<td>-B</td>
<td>&ndash;backup-path</td>
<td>BACKUP_PATH</td>
<td>Yes</td>
<td>location of the backup storage area</td>
<td></td>
</tr>
<tr>
<td>-A</td>
<td>&ndash;arclog-path</td>
<td>ARCLOG_PATH</td>
<td>Yes</td>
<td>location of archive WAL storage area</td>
<td></td>
</tr>
<tr>
<td>-S</td>
<td>&ndash;srvlog-path</td>
<td>SRVLOG_PATH</td>
<td>Yes</td>
<td>location of server log storage area</td>
<td></td>
</tr>
<tr>
<td>-b</td>
<td>&ndash;backup-mode</td>
<td>BACKUP_MODE</td>
<td>Yes</td>
<td>backup mode (full, incremental, or archive)</td>
<td></td>
</tr>
<tr>
<td>-s</td>
<td>&ndash;with-serverlog</td>
<td>WITH_SERVERLOG</td>
<td>Yes</td>
<td>also backup server log files</td>
<td>specify boolean type in environmental variable or configuration file</td>
</tr>
<tr>
<td>-Z</td>
<td>&ndash;compress-data</td>
<td>COMPRESS_DATA</td>
<td>Yes </td>
<td>compress data backup with zlib </td>
<td>specify boolean type in environmental variable or configuration file</td>
</tr>
<tr>
<td>-C</td>
<td>&ndash;smooth-checkpoint</td>
<td>SMOOTH_CHECKPOINT</td>
<td>Yes</td>
<td>do smooth checkpoint before backup</td>
<td>specify boolean type in environmental variable or configuration file</td>
</tr>
<tr>
<td></td>
<td>&ndash;standby-host</td>
<td>STANDBY_HOST</td>
<td>Yes</td>
<td>standby server host or socket directory</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;standby-port</td>
<td>STANDBY_PORT</td>
<td>Yes</td>
<td>standby server port</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;keep-data-generations</td>
<td>KEEP_DATA_GENERATIONS</td>
<td>Yes</td>
<td>keep GENERATION of full data backup</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;keep-data-days</td>
<td>KEEP_DATA_DAYS</td>
<td>Yes</td>
<td>keep enough data backup to recover to DAY days age</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;keep-srvlog-files</td>
<td>KEEP_SRVLOG_FILES</td>
<td>Yes</td>
<td>keep NUM of serverlogs </td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;keep-srvlog-days </td>
<td>KEEP_SRVLOG_DAYS</td>
<td>Yes</td>
<td>keep serverlog modified in DAY days</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;keep-arclog-files</td>
<td>KEEP_ARCLOG_FILES</td>
<td>Yes</td>
<td>keep NUM of archived WAL</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;keep-arclog-days</td>
<td>KEEP_ARCLOG_DAYS</td>
<td>Yes</td>
<td>keep archived WAL modified in DAY days</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;recovery-target-timeline</td>
<td>RECOVERY_TARGET_TIMELINE</td>
<td>Yes</td>
<td>recovering into a particular timeline</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;recovery-target-xid</td>
<td>RECOVERY_TARGET_XID</td>
<td>Yes</td>
<td>transaction ID up to which recovery will proceed</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;recovery-target-time</td>
<td>RECOVERY_TARGET_TIME</td>
<td>Yes</td>
<td>time stamp up to which recovery will proceed</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;recovery-target-inclusive</td>
<td>RECOVERY_TARGET_INCLUSIVE</td>
<td>Yes</td>
<td>whether we stop just after the recovery target</td>
<td></td>
</tr>
<tr>
<td></td>
<td>&ndash;hard-copy</td>
<td>HARD_COPY</td>
<td>Yes</td>
<td>how to restore archive WAL</td>
<td>specify boolean type in environmental variable or configuration file</td>
</tr>
</tbody>
</table>


<ul>
<li>The names of variable in configuration file are the same as long names or names of environment variables.</li>
<li>The password can not be specified in command line and configuration file for security reason.</li>
</ul>


<p>This utility, like most other PostgreSQL utilities, also uses the environment variables supported by libpq (see <a href="http://www.postgresql.org/docs/current/static/libpq-envars.html">Environment Variables</a>)</p>

<h1 id="restrictions">Restrictions</h1>

<p>pg_rman has the following restrictions.</p>

<ul>
<li>Requires to read database cluster directory and write backup catalog directory. For example, you need to mount the disk where backup catalog is placed with NFS from database server.</li>
<li>Block sizes of pg_rman and server should be matched. BLCKSZ and XLOG_BLCKSZ also should be matched.</li>
<li>If there are some unreadable files/directories in database cluster directory, WAL directory or archived WAL directory, the backup or restore would be failed.</li>
<li>When taking an incremental backup, pg_rman check the timeline ID of the target database whether it is the same with the one of the full backup in backup list. But, pg_rman does not check whether the data itself is same with the full backup in backup list. So, you can take an incremental backup over the full backup against the database which has the same timeline ID but has different data.</li>
</ul>


<p>Getting backup from standby-site, pg_rman has the follow restrictions too.</p>

<ul>
<li>The environment of replication should be built right, or the backup will not finish.</li>
<li>You can&rsquo;t get backups on master and standby at the same time.</li>
<li>You can&rsquo;t get backups on multi standbys at the same time too.</li>
<li>Basically, the backup from standby-site is used for restoring on MASTER. pg_rman doesn&rsquo;t treat the backup as restoring on standby automatically.</li>
<li>If you want to restore the backup on STANDBY, you have to manage archive logs with your self.</li>
</ul>


<p>When using storage snapshot, pg_rman has the following restrictions too.</p>

<ul>
<li>If your snapshot does not have any file update time, incremental backup is same with full backup.</li>
<li>Because pg_rman judges performing full backup or incremental backup by update time for files. If files don&rsquo;t have update time because of storage snapshot specification, pg_rman performs full backup every time.</li>
<li>You can&rsquo;t backup for one side works storage with split mirror snapshot.</li>
<li>Before you execute pg_rman, you should perform storage &ldquo;RESYNC&rdquo;.</li>
<li>After pg_rman performs backup with split mirror snapshot, storeage will be &ldquo;SPLITTED&rdquo;(works on one side).

<ul>
<li>pg_rman perform SPLIT command for getting snapshot, but doesn&rsquo;t perform RESYNC command.</li>
</ul>
</li>
<li>You cant&rsquo;t get snapshot from different vendor storages in a time.</li>
<li>You cant&rsquo;t use some vendor storages which have different commands for getting snapshot.</li>
<li>The script and commands for getting storage snapshot should be executable.</li>
<li>It&rsquo;s expected to have authority of root for getting snapshot or mounting volumes. So a user, performs pg_rman, is granted to execute any commands in the script.</li>
<li>If you use LVM(Logical Volume Manager), it&rsquo;s needed root authority for mount, umount, lvcreate, lvremove, lvscan commands. You should granted to these commands with sudo command to non-password executable.</li>
</ul>


<h1 id="details">Details</h1>

<h2>Recovery to Point-in-Time</h2>

<p>pg_rman can recover to point-in-time if timeline, transaction ID, or timestamp are specified in recovery. pg_xlogdump(<a href="http://www.postgresql.org/docs/current/static/pgxlogdump.html">9.3 or later</a>)xlogdump(<a href="http://github.com/snaga/xlogdump/">9.2 or before</a>) is an useful tool to check the contents of WAL files and determine when to recover. See <a href="http://www.postgresql.org/docs/current/static/continuous-archiving.html">Continuous Archiving and Point-in-Time Recovery (PITR)</a> for the details.</p>

<h2>Configuration file</h2>

<p>Setting parameters can be specified with form of &ldquo;<code>name=value</code>&rdquo; in the configuration file. Quotes are required if the value contains whitespaces. Comments starts with &ldquo;<code>#</code>&rdquo;. Whitespaces and tabs are ignored excluding values.</p>

<h2>Exit codes</h2>

<p>pg_rman returns exit codes for each error status.</p>

<table>
<thead>
<tr>
<th>Code</th>
<th>Name</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>SUCCESS</td>
<td>Succeeded.</td>
</tr>
<tr>
<td>1</td>
<td>HELP</td>
<td>Print a help, then exit.</td>
</tr>
<tr>
<td>2</td>
<td>ERROR</td>
<td>Generic error.</td>
</tr>
<tr>
<td>3</td>
<td>FATAL</td>
<td>Exit because of repeated errors</td>
</tr>
<tr>
<td>4</td>
<td>PANIC</td>
<td>Unknown critical condition.</td>
</tr>
<tr>
<td>10</td>
<td>ERROR_SYSTEM</td>
<td>I/O or system error.</td>
</tr>
<tr>
<td>11</td>
<td>ERROR_NOMEM</td>
<td>Out of memory.</td>
</tr>
<tr>
<td>12</td>
<td>ERROR_ARGS</td>
<td>Invalid input parameters.</td>
</tr>
<tr>
<td>13</td>
<td>ERROR_INTERRUPTED</td>
<td>Interrupted by user. (Ctrl+C etc.)</td>
</tr>
<tr>
<td>14</td>
<td>ERROR_PG_COMMAND</td>
<td>SQL error.</td>
</tr>
<tr>
<td>15</td>
<td>ERROR_PG_CONNECT</td>
<td>Cannot connect to PostgreSQL server.</td>
</tr>
<tr>
<td>20</td>
<td>ERROR_ARCHIVE_FAILED</td>
<td>Cannot archive WAL files.</td>
</tr>
<tr>
<td>21</td>
<td>ERROR_NO_BACKUP</td>
<td>Backup file not found.</td>
</tr>
<tr>
<td>22</td>
<td>ERROR_CORRUPTED</td>
<td>Backup file is broken.</td>
</tr>
<tr>
<td>23</td>
<td>ERROR_ALREADY_RUNNING</td>
<td>Cannot start because another pg_rman is running.</td>
</tr>
<tr>
<td>24</td>
<td>ERROR_PG_INCOMPATIBLE</td>
<td>Version conflicted with PostgreSQL server.</td>
</tr>
<tr>
<td>25</td>
<td>ERROR_PG_RUNNING</td>
<td>Cannot restore because PostgreSQL server is running.</td>
</tr>
<tr>
<td>26</td>
<td>ERROR_PID_BROKEN</td>
<td>postmaster.pid file is broken.</td>
</tr>
</tbody>
</table>


<h1 id="externalscript">External Scripts</h1>

<p>This is the script to getting snapshot and mounting file systems. If you want to add outer scripts, you should make your script corresponding outer script interface according to referring manuals of the storage. Please refer <strong>Interface Specification</strong> about what you should make.</p>

<p>Outer script performs some operation for getting several snapshots in a time execution.</p>

<p>If you want to use outer script, you should set the script in backup catalog directory and rename it to &ldquo;<code>snapshot_script</code>&rdquo;.</p>

<p>A sample outer script is released for LVM(Logical Volume Manager).</p>

<h2>Commands Specification</h2>

<pre><code>$ ${BACKUP_PATH}/snapshot_script { split | resync | mount | umount | freeze | unfreeze } [cleanup]
</code></pre>

<ul>
<li>Input

<ul>
<li>first argument <code>{ split | resync | mount | umount | freeze | unfreeze }</code>

<ul>
<li>identifier for performing</li>
</ul>
</li>
<li>second argument <code>[cleanup]</code>

<ul>
<li>If you specified <code>cleanup</code>, error occurring doesn&rsquo;t stop the process. just output warning messages.</li>
<li>this argument is for <code>resync</code>, <code>umount</code>, <code>unfreeze</code> only.</li>
</ul>
</li>
</ul>
</li>
<li>Output

<ul>
<li>Making snapshot volume by performing <code>split</code> operation.</li>
<li>Freezing filesystem I/O by performing <code>freeze</code> operation.</li>
<li>Mounting to snapshot volume by performing <code>mount</code> operation.</li>
<li>standard output

<ul>
<li>output tablespace name in the snapshot by performing <code>split</code> operation.</li>
<li>output tablespace name and its directory by performing <code>mount</code> operation. The template is &lt;tablespace name&gt;=&lt;path to directory for the tablespace&gt;</li>
<li>The command performs without any errors, output &ldquo;<code>SUCCESS</code>&rdquo;, otherwise output nothing. If the command is <code>split</code> or <code>mount</code>, output in last line.</li>
</ul>
</li>
<li>standard error output

<ul>
<li>output log messages.</li>
</ul>
</li>
<li>return value

<ul>
<li>Not Specified.</li>
</ul>
</li>
</ul>
</li>
</ul>


<h2>Interface Specification</h2>

<ul>
<li><code>split</code>

<ul>
<li>Making procedure for getting snapshots.</li>
<li>Output tablespace name in the snapshots to standard output.

<ul>
<li>If database cluster is included in a snapshot, the tablespace name should be &ldquo;<code>PG-DATA</code>&rdquo;.</li>
<li>If some tablespaces are included in a snapshot, output them with multi lines.</li>
</ul>
</li>
</ul>
</li>
<li><code>resync [cleanup]</code>

<ul>
<li>Making procedure for removing snapshot made by <code>split</code> operation.</li>
<li>If you don&rsquo;t need to remove snapshot, like split mirror snapshot, you don&rsquo;t make any procedure.</li>
<li>If <code>cleanup</code> is specified and occurring errors, output warning messages and continue to get rest snapshots.</li>
</ul>
</li>
<li><code>mount</code>

<ul>
<li>Making procedure for mounting the snapshot made by <code>split</code> operation to the filesystem.</li>
<li>output tablespace name and its directory(absolute path) to standard output. The template is [&lt;tablespace name&gt;=&lt;directory path&gt;].

<ul>
<li>If database cluster is included in a snapshot, the tablespace name should be &ldquo;<code>PG-DATA</code>&rdquo;.</li>
<li>If some tablespaces are included in a snapshot, output them with multi lines.</li>
</ul>
</li>
</ul>
</li>
<li><code>umount [cleanup]</code>

<ul>
<li>Making procedure for unmounting the snapshot made by <code>mount</code> operation.</li>
<li>If <code>cleanup</code> is specified and occurring errors, output warning messages and continue to unmount rest snapshots.</li>
</ul>
</li>
<li><code>freeze</code>

<ul>
<li>Making procedure for freezing filesystem IO.</li>
<li>If your storage doesn&rsquo;t need to freeze filesystem IO, you don&rsquo;t make any procedure.</li>
</ul>
</li>
<li><code>unfreeze [cleanup]</code>

<ul>
<li>Making procedure for unfreezing filesystem IO by performing <code>freeze</code> operation.</li>
<li>If your storage doesn&rsquo;t need to freeze filesystem IO, you don&rsquo;t make any procedure.</li>
<li>If cleanup is specified and occurring errors, output warning messages and continue to unfreeze rest filesystems.</li>
</ul>
</li>
</ul>


<h2>Explanation for sample script for LVM(Logical Volume Manager)</h2>

<ul>
<li><p><code>split</code></p>

<ul>
<li><p>perform lvcreate command as root authority against a volume for getting snapshot.</p>

<pre><code>  $ sudo /usr/sbin/lvcreate --snapshot --size=2G --name snap00 /dev/VolGroup00/LogVolume00
</code></pre></li>
<li><p>Above example is getting snapshot for logical volume &ldquo;LogVolume00&rdquo;.</p></li>
<li>Snapshot name, snapshot size and logical volume for getting snapshot are parameterable.</li>
<li>Output tablespace names for backup to standard output.</li>
</ul>
</li>
<li><p><code>resync</code></p>

<ul>
<li><p>perform lvremove command as root authority against a volume for getting snapshot.</p>

<pre><code>  $ sudo /usr/sbin/lvremove -f /dev/VolGroup00/snap00
</code></pre></li>
</ul>
</li>
<li><p><code>mount</code></p>

<ul>
<li><p>perform mount command as root authority against a volume for getting snapshot.</p>

<pre><code>  $ sudo /bin/mount /dev/VolGroup00/snap00 /mnt/snapshot_lvm/pgdata
</code></pre></li>
<li><p>Above example is mounting snapshot volume made by split operation to &ldquo;/mnt/snapshot_lvm/pgdata&rdquo;.</p></li>
<li>Mounting directory name can be parameterized.</li>
<li>Output tablespace names and corresponding mounting direcotry name to standard output.</li>
</ul>
</li>
<li><p><code>umount</code></p>

<ul>
<li><p>perform umount command as root authority against a volume for getting snapshot.</p>

<pre><code>  $ sudo /bin/umount /mnt/snapshot_lvm/pgdata
</code></pre></li>
</ul>
</li>
<li><p><code>freeze</code></p>

<ul>
<li>noting to do. (not need file system freeze)</li>
</ul>
</li>
<li><p><code>unfreeze</code></p>

<ul>
<li>noting to do. (not need file system freeze)</li>
</ul>
</li>
</ul>

<h1 id="download">Download</h1>
<p>You can download pg_rman rpm packages and source from: <a href="http://github.com/ossc-db/pg_rman/releases">Click here to download pg_rman</a>  </p>
<br>

<h1 id="Installations">Installations</h1>

<p>pg_rman can be installed as same as standard contrib modules.</p>
<p>No need to register to databases.</p>

<h2 id="Build.from.source">Build from source</h2>

<p>The module can be built with pgxs.</p>

<pre><code>$ cd pg_rman
$ make
$ make install
</code></pre>

<h2 id="Install.from.rpm">Install from rpm package</h2>
<p>Download rpm which name contains the PostgreSQL version and OS version of your environment.</p>
<pre><code># rpm -ivh pg_rman-x.x.xx-x.pgxx.rhelx.x86_64.rpm
</code></pre>


<h1 id="requirement">Requirements</h1>
<dl>
<dt>PostgreSQL</dt>
<dd>PostgreSQL 8.4, 9.0, 9.1, 9.2, 9.3, 9.4, 9.5, 9.6</dd>
<dt>OS</dt>
<dd>RHEL 5/6/7, Ubuntu 12.04LTS</dd>
</dl>


<h1 id="seealso">See Also</h2>
<a href="http://www.postgresql.org/docs/current/interactive/backup.html">Backup and Restore</a>

<hr />

<p class="footer">Copyright (c) 2009-2016, NIPPON TELEGRAPH AND TELEPHONE CORPORATION</p>

</body>
</html>
